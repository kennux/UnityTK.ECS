using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using System.Reflection;
using System.Text;

namespace UnityTK
{
    /// <summary>
    /// Static reflection cache class.
    /// Provides cached access to the reflection api and some helper methods to work with reflection.
    /// </summary>
    public static class ReflectionHelper
    {
        private static Dictionary<Type, List<Type>> assignableToCache = new Dictionary<Type, List<Type>>();
        private static Dictionary<Type, Dictionary<string, MethodInfo>> methodCache = new Dictionary<Type, Dictionary<string, MethodInfo>>();

        /// <summary>
        /// Alternative to <see cref="Type.AssemblyQualifiedName"/> which is a bit less detailed.
        /// It returns a string in this format: [Namespace].[Type], [Assembly] - Example: UnityEngine.UI.InputField, UnityEngine.UI
        /// </summary>
        public static string GetSimpleAssemblyQualifiedName(this Type type)
        {
            return string.Format("{0}, {1}", type.FullName, type.Assembly.GetName().Name);
        }

        /// <summary>
        /// Returns a string for the specified type which is unique, can be used to retrive this type via <see cref="TypeFromString(string)"/>
        /// </summary>
        public static string TypeToString(Type t)
        {
            return t.GetSimpleAssemblyQualifiedName();
        }

        /// <summary>
        /// Retrieves a type from a string previously gathered via <see cref="TypeToString(Type)"/>
        /// </summary>
        public static Type TypeFromString(string s)
        {
            return Type.GetType(s);
        }

        /// <summary>
        /// Creates a string uniquely identifying the specified method info on it's declaring type.
        /// <see cref="MethodFromString(string, Type)"/>
        /// </summary>
        public static string MethodToString(MethodInfo methodInfo)
        {
            // Gather info and init string builder
            var parameters = methodInfo.GetParameters();
            StringBuilder parametersString = new StringBuilder();

            for (int i = 0; i < parameters.Length; i++)
            {
                parametersString.Append(parameters[i].ParameterType.GetSimpleAssemblyQualifiedName());

                if (i < parameters.Length - 1)
                    parametersString.Append('|');
            }

            return string.Format("{0}:({1})", methodInfo.Name, parametersString.ToString());
        }

        /// <summary>
        /// Retrieves a method info from a specific type using a method string previously generated by <see cref="MethodToString(MethodInfo)"/>
        /// </summary>
        public static MethodInfo MethodFromString(string method, System.Type type)
        {
            // Get cache dictionary for the specified type
            Dictionary<string, MethodInfo> cacheDict = null;
            if (!methodCache.TryGetValue(type, out cacheDict))
            {
                // No cached dict existing, create one
                cacheDict = DictionaryPool<string, MethodInfo>.Get();
                methodCache.Add(type, cacheDict);
            }

            MethodInfo methodInfo = null;
            if (!cacheDict.TryGetValue(method, out methodInfo))
            {
                string[] parts = method.Split(':');

                if (parts.Length != 2)
                    return null;

                // Get parameters
                var pString = parts[1].Replace("(", "").Replace(")", "");
                string[] paramStrings = string.IsNullOrEmpty(pString) ? new string[0] : pString.Split('|');
                Type[] paramTypes = new Type[paramStrings.Length];

                for (int i = 0; i < paramStrings.Length; i++)
                    paramTypes[i] = ReflectionHelper.TypeFromString(paramStrings[i]);

                // Get method and write cache
                methodInfo = type.GetMethod(parts[0], paramTypes);
                cacheDict.Add(method, methodInfo);
            }

            return methodInfo;
        }

        /// <summary>
        /// Returns the default value for the specified type.
        /// </summary>
        public static object GetDefaultValue(Type t)
        {
            if (t.IsValueType)
                return Activator.CreateInstance(t);
            else
                return null;
        }

        /// <summary>
        /// Returns _all_ types assignable to the specified type.
        /// </summary>
        /// <param name="assignableTo">The type the returned types have to be assignable to.</param>
        /// <param name="preAlloc">Pre-allocated list with types that will be reused.</param>
        /// <returns>A list with all types that can be assigned to assignableTo, <see cref="Type.IsAssignableFrom(Type)"/><returns>
        public static List<Type> GetAllTypesAssignableTo(Type assignableTo, List<Type> preAlloc = null)
        {
            if (preAlloc == null)
                preAlloc = new List<Type>();

            List<Type> lst;
            if (assignableToCache.TryGetValue(assignableTo, out lst))
            {
                preAlloc.AddRange(lst);
                return preAlloc;
            }

            lst = new List<Type>();
            foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
                foreach (var type in assembly.GetTypes())
                {
                    if (assignableTo.IsAssignableFrom(type))
                    {
                        lst.Add(type);
                    }
                }

            assignableToCache.Add(assignableTo, lst);
            preAlloc.AddRange(lst);
            return preAlloc;
        }
    }
}